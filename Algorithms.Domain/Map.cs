using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Algorithms.Domain
{
    public sealed class Map
    {
        private readonly int _width;
        private readonly int _height;
        private bool _allowDiagonalMovement;
        private readonly int _totalTiles;
        private readonly MapTile[] _tiles;

        public int Width => _width;
        public int Height => _height;

        public bool AllowDiagonalMovement
        {
            get { return _allowDiagonalMovement; }
            set { _allowDiagonalMovement = value; }
        }

        public event MapTileChanged TileChanged;

        public Map(int width, int height, bool allowDiagonalMovement)
        {
            _width = width;
            _height = height;
            _allowDiagonalMovement = allowDiagonalMovement;
            _tiles = new MapTile[_totalTiles = _width * _height];
        }

        public IEnumerable<MapLocation> GetNeighbors(MapLocation origin)
        {
            foreach (var neighbor in GetNeighborsUnsafe(origin))
                if (ConstrainToBounds(neighbor) == neighbor)
                    yield return neighbor;
        }

        private IEnumerable<MapLocation> GetNeighborsUnsafe(MapLocation origin)
        {
            yield return origin.Move(MapDirection.North, 1);
            yield return origin.Move(MapDirection.East, 1);
            yield return origin.Move(MapDirection.South, 1);
            yield return origin.Move(MapDirection.West, 1);

            if (_allowDiagonalMovement)
            {
                yield return origin.Move(MapDirection.North | MapDirection.East, 1);
                yield return origin.Move(MapDirection.South | MapDirection.East, 1);
                yield return origin.Move(MapDirection.South | MapDirection.West, 1);
                yield return origin.Move(MapDirection.North | MapDirection.West, 1);
            }
        }

        /// <summary>
        /// Gets a copy of the map tile at the given <paramref name="location"/>
        /// </summary>
        /// <param name="location">The location of the map tile to return</param>
        /// <returns>A copy of the map tile.</returns>
        public MapTile GetTile(MapLocation location)
        {
            int index = GetTileIndex(location);
            CheckTileIndex(index, true);
            return _tiles[index];
        }

        /// <summary>
        /// Sets the map tile at the given <paramref name="location"/> to the tile generated by <paramref name="tileTemplate"/>
        /// </summary>
        /// <param name="location">The location of the map tile to change.</param>
        /// <param name="tileTemplate">The template to use to generate the map tile.</param>
        /// <param name="throwOnOutOfBounds">Whether or not an exception should be thrown if the given location is outside the bounds of the map.</param>
        public void SetTile(MapLocation location, MapTileTemplate tileTemplate, bool throwOnOutOfBounds)
        {
            SetTile(location, tileTemplate.CreateTile(), throwOnOutOfBounds);
        }

        private void SetTile(MapLocation location, MapTile tile, bool throwOnOutOfBounds)
        {
            int index = GetTileIndex(location);
            if (!CheckTileIndex(index, throwOnOutOfBounds))
                return;

            var oldValue = _tiles[index];
            _tiles[index] = tile;
            TileChanged?.Invoke(location, oldValue, tile);
        }

        /// <summary>
        /// Returns a new <see cref="MapLocation"/> relative to the given <paramref name="location"/> that is constrained to the bounds of the map.
        /// </summary>
        public MapLocation ConstrainToBounds(MapLocation location)
        {
            var result = location;
            result.X = Math.Max(0, Math.Min(Width - 1, result.X));
            result.Y = Math.Max(0, Math.Min(Height - 1, result.Y));
            return result;
        }

        public int GetTileIndex(MapLocation location)
        {
            return (location.X * _height) + location.Y;
        }

        public int GetTileIndex(int x, int y)
        {
            return (x * _height) + y;
        }

        [DebuggerHidden]
        [DebuggerStepThrough]
        private bool CheckTileIndex(int index, bool throwException)
        {
            if (index < 0 || index >= _totalTiles)
            {
                if (throwException)
                    throw new IndexOutOfRangeException("MapLocation is outside the bounds of the map.");
                return false;
            }

            return true;
        }

        public unsafe void Save(string filePath)
        {
            using (BinaryWriter writer = new BinaryWriter(File.Create(filePath)))
            {
                fixed (MapTile* pTiles = _tiles)
                {
                    int* data = (int*) pTiles;

                    for (int i = 0; i < _tiles.Length; i++)
                        writer.Write(data[i]);
                }
            }
        }

        public unsafe void Load(string filePath)
        {
            using (BinaryReader reader =
                new BinaryReader(File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
            {
                fixed (MapTile* pTiles = _tiles)
                {
                    int* data = (int*)pTiles;

                    for (int i = 0; i < _tiles.Length; i++)
                        data[i] = reader.ReadInt32();
                }
            }
        }
    }


    public delegate void MapTileChanged(MapLocation location, MapTile oldValue, MapTile newValue);
}